<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>金星満ち欠けシミュレーター 完全版</title>
    <style>
        body { background-color: #0a0a0c; color: #e0e0e0; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        .container { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; }
        canvas { border: 1px solid #444; background-color: #000; border-radius: 8px; }
        .controls { margin-bottom: 20px; padding: 20px; background: #1a1a1d; border-radius: 12px; border: 1px solid #333; text-align: center; }
        button { padding: 10px 20px; font-size: 14px; cursor: pointer; background: #444; color: white; border: none; border-radius: 5px; margin: 0 5px; }
        button.active { background: #007bff; font-weight: bold; }
        .info { margin-top: 10px; font-size: 0.9em; color: #ffca00; }
    </style>
</head>
<body>

    <h2>金星の満ち欠けシミュレーター</h2>

    <div class="controls">
        <button id="modeNormal" class="active">通常の公転モード</button>
        <button id="modeFixed">地球・太陽 固定モード</button>
        <div style="margin-top: 15px;">
            公転速度: <input type="range" id="speedRange" min="0" max="0.05" step="0.001" value="0.01">
        </div>
        <div class="info" id="statusLabel">宵の明星（夕方の西の空）</div>
    </div>

    <div class="container">
        <div>
            <div style="text-align:center; margin-bottom:5px;">1. 位置関係（俯瞰）</div>
            <canvas id="orbitCanvas" width="450" height="450"></canvas>
        </div>
        <div>
            <div style="text-align:center; margin-bottom:5px;">2. 地球から見た金星</div>
            <canvas id="viewCanvas" width="450" height="450"></canvas>
        </div>
    </div>

    <script>
        const orbitCanvas = document.getElementById('orbitCanvas');
        const orbitCtx = orbitCanvas.getContext('2d');
        const viewCanvas = document.getElementById('viewCanvas');
        const viewCtx = viewCanvas.getContext('2d');
        const speedInput = document.getElementById('speedRange');
        const statusLabel = document.getElementById('statusLabel');

        let angleEarth = -Math.PI / 2;
        let angleVenus = -Math.PI / 2 + 0.5; 
        let isFixedMode = false;

        const cx = 225, cy = 225;
        const orbitR_V = 100; // 金星の軌道半径
        const orbitR_E = 170; // 地球の軌道半径

        document.getElementById('modeNormal').onclick = (e) => {
            isFixedMode = false;
            updateButtons(e.target);
        };
        document.getElementById('modeFixed').onclick = (e) => {
            isFixedMode = true;
            updateButtons(e.target);
        };

        function updateButtons(target) {
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            target.classList.add('active');
        }

        function draw() {
            orbitCtx.clearRect(0, 0, 450, 450);
            viewCtx.clearRect(0, 0, 450, 450);

            const speed = parseFloat(speedInput.value);
            angleEarth -= speed; 
            angleVenus -= speed * 1.62; // 金星の方が速い

            // 1. 座標計算
            let ex, ey, vx, vy, sx, sy;
            
            if (isFixedMode) {
                // 地球と太陽を固定（地球を下、太陽を中央）
                sx = cx; sy = cy;
                ex = cx; ey = cy + 170;
                vx = sx + orbitR_V * Math.cos(angleVenus - angleEarth - Math.PI/2);
                vy = sy + orbitR_V * Math.sin(angleVenus - angleEarth - Math.PI/2);
            } else {
                // 通常の公転
                sx = cx; sy = cy;
                ex = sx + orbitR_E * Math.cos(angleEarth);
                ey = sy + orbitR_E * Math.sin(angleEarth);
                vx = sx + orbitR_V * Math.cos(angleVenus);
                vy = sy + orbitR_V * Math.sin(angleVenus);
            }

            // --- 左側：位置関係の描画 ---
            // 太陽
            orbitCtx.fillStyle = "yellow";
            orbitCtx.beginPath(); orbitCtx.arc(sx, sy, 20, 0, Math.PI * 2); orbitCtx.fill();
            
            // 軌道
            orbitCtx.strokeStyle = "#333";
            orbitCtx.setLineDash([5, 5]);
            orbitCtx.beginPath(); orbitCtx.arc(sx, sy, orbitR_V, 0, Math.PI * 2); orbitCtx.stroke();
            if(!isFixedMode) {
                orbitCtx.beginPath(); orbitCtx.arc(sx, sy, orbitR_E, 0, Math.PI * 2); orbitCtx.stroke();
            }

            // 地球と金星を結ぶ線
            orbitCtx.strokeStyle = "rgba(255, 255, 255, 0.2)";
            orbitCtx.setLineDash([]);
            orbitCtx.beginPath(); orbitCtx.moveTo(ex, ey); orbitCtx.lineTo(vx, vy); orbitCtx.stroke();

            // 地球
            orbitCtx.fillStyle = "#44f";
            orbitCtx.beginPath(); orbitCtx.arc(ex, ey, 10, 0, Math.PI * 2); orbitCtx.fill();

            // 金星
            orbitCtx.fillStyle = "#ff0";
            orbitCtx.beginPath(); orbitCtx.arc(vx, vy, 7, 0, Math.PI * 2); orbitCtx.fill();

            // --- 右側：地球からの見え方（満ち欠け） ---
            const dx = vx - ex;
            const dy = vy - ey;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // 地球から見た太陽方向と金星方向の角度
            const angleToSun = Math.atan2(sy - ey, sx - ex);
            const angleToVenus = Math.atan2(vy - ey, vx - ex);
            
            // 離角 (Elongation)
            let diffAngle = angleToVenus - angleToSun;
            
            // 満ち欠けの割合 (Phase: 0=新月, 0.5=半月, 1.0=満月)
            // 外合(180度)で1、内合(0度)で0になる式
            const phase = (1 + Math.cos(diffAngle)) / 2;

            // ラベル更新
            const deg = ((diffAngle * 180 / Math.PI) + 360) % 360;
            if (deg > 0 && deg < 180) statusLabel.textContent = "宵の明星（夕方の西の空）";
            else statusLabel.textContent = "明けの明星（明け方の東の空）";

            viewCtx.save();
            viewCtx.translate(225, 225);
            
            // 距離に応じた大きさ（内合で大きく、外合で小さく）
            const displayR = 10000 / dist; 

            // 影の向き（常に太陽と反対側を向く）
            viewCtx.rotate(angleToVenus + Math.PI/2);

            // 暗い部分
            viewCtx.fillStyle = "#222";
            viewCtx.beginPath(); viewCtx.arc(0, 0, displayR, 0, Math.PI * 2); viewCtx.fill();

            // 光っている部分の描画
            viewCtx.fillStyle = "#fffca0";
            viewCtx.shadowBlur = 10; viewCtx.shadowColor = "#fffca0";
            
            const cosD = Math.cos(diffAngle);
            
            viewCtx.beginPath();
            // 右半分を描画
            viewCtx.arc(0, 0, displayR, -Math.PI/2, Math.PI/2, false);
            // 左半分の弧を位相によって変化させる
            // 反時計回りなので、cosDの符号で膨らみと凹みを制御
            viewCtx.ellipse(0, 0, displayR * Math.abs(cosD), displayR, 0, Math.PI/2, -Math.PI/2, cosD < 0);
            viewCtx.fill();

            viewCtx.restore();

            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>
